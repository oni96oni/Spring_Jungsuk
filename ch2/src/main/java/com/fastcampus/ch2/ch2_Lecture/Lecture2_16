서블릿과 JSP
	11.JSTL (JSP Standard Tag Library)
		<%= 값%> 을 편리하게 작성하려고 EL(${})탄생, <% %>을 편리하게 작성하려고 JSTL이 탄생!
		태그라이브러리를 작성해야 태그들을 사용할 수 있다.
		jstl이 없으면 자바, html이 섞여있어서 구분하기 어려움 그래서 사용한다.
		<% ~ %>같은것을 안쓰기위해서 JSTL이 탄생. 없으면 너무 어렵고 에러발생확률이 높아서.
		<c:set var="to" value="10"/> 같은식으로 작성하는 이유는 EL이 lv를 사용할 수 없기 때문에 저장소에 저장하는것이다! 
		map구조에다가 저장(K="to",V="10"), scope이 없다면 scope = "page"가 생략되어 있는것이다.
		<c:forEach>는 반복문! varStatus는 count,index를 갖고있다.
			count는 1부터 시작, index는 0부터 시작
		배열의 요소(items)를 var(elem)에 집어넣는것! 배열의 길이 만큼!
		
		<c:out>태그를 안쓰고 값을 입력받으면, 태그들을 이용한 공격이 들어올 수도 있다.
		<c:out>태그로 감싸서 출력을 하면 태그들을 해석을 안하고 그대로 출력한다. script공격을 방어할 수 있다. 
				
	12.Filter
		공통적인 요청받은뒤 전처리와 응답전 후처리에 사용, 로깅, 인코딩 등 변환할때 Filter를 사용한다.
		서블릿들이 있을때 전처리, 후처리를 진행하는데 그 부분들이 서블릿마다 중복된다면 Filter를 사용해서 중복코드를 분리한다.
		중복코드를 분리할때 사용.
		공통된 입력부분을 디스페쳐서블릿으로 분리
		AOP개념과 Filter개념과 매우 유사. 코드의 분리와 중복제거 때문에 여러가지 개념, 기술들이 등장.
		필터가 여러개일 수도 있다.
		
		요청이오면 필터가 전처리후 서블릿을 호출 그다음에 서블릿에서 처리를 진행한뒤에 다시 필터로 와서 후처리를 진행한 뒤에 응답한다.
		
		필터가 있음으로써 전처리와 후처리를 서블릿마다 넣지않고 하나의 서블릿에 두었다가 사용할 수 있다. 또한 추가/제거/변경 용이
		전처리 후처리 꼭 양쪽 다 있어야 하는것은 아니다. 한쪽만 있어도 괜찮다.
		@WebFilter 어노테이션은 필터를 등록!
		urlPatterns -> 어떤 요청에 필터를 적용할건가. 보통 패턴을 적음. /* 는 모든요청에 이 필터를 적용하라는 뜻
		원래 소요시간을 측정하려면 서블릿마다 코드를 앞뒤로 작성해주어야 하지만 필터를 적용함으로써 그냥 실행만해도 자동으로 측정되게 하였다.
		PerformanceFilter를 만든후에 jsp파일에 접속하면 소요시간이 출력된다. 
		역시나 처음에는 변환하고 컴파일하느라 처음에만 소요시간이 오래걸리고 그 이후부터는 만들어져 있으므로 소요시간이 감소된다.
		
		사용법은 doFilter라는 메서드를 오버라이딩하고 chain.doFilter(request, response); 만남겨두고 그위로 전처리 그 아래로 후처리작업에 사용할
		코드를 작성해주면 된다!
		
		