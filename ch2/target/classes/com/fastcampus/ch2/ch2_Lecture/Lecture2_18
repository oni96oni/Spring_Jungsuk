@RequestParam과 @ModelAttribute
	2.@ModelAttribute
		적용 대상을 Model의 '속성'으로 자동 추가해주는 애너테이션 -> Model에 자동저장! (Model은 key, value값을 가진 map)
		@ModelAttribute("key") 이렇게 키값을 입력해주어야 하는데 입력하지 않으면 애너테이션이 붙은 매개변수의 이름에 첫글자를 소문자로한것을 key값으로 한다.
		(1)반환타입 또는 (2)컨트롤러 메서드의 매개 변수에 적용 가능, 반환타입에 사용할때는 key를 꼭 붙여주어야한다.
		반환타입 앞에 다가 @ModelAttribute를 붙이면 따로 호출할 필요도 없고, 저장도 따로할 필요가 없다. 코드절약가능 ★호출 결과를 모델에다가 저장을 하니까!
		호출결과가 값이된다. key값은 애너테이션뒤에 붙어있는것이 되고
		그런데 @ModelAttribute은 생략가능하다! 
		
		m.addAttribute이런 코드를 생략할 수 있게 된다.
		
		컨트롤러의 메서드중에 @ModelAttribute가 붙어있으면 전부 호출을 한다 그리고 그 결과를 전부 model에 저장한다.
		
		★★컨트롤러의 매개변수에 쓸수있는 애너테이션 2개가 있다.
			@RequestParam 	컨트롤러의 매개변수의 타입이 기본형, String 일때는 @RequestParam가 생략되었다고 보면된다.
			@ModelAttribute	컨트롤러의 매개변수의 타입이 참조형일때는 @ModelAttribute가 생략되었다고 보면 된다.
		
		참조형일때는 @RequestParam 붙일 수 없다. 왜? 여러개의 값이 바인딩 되기 때문에!
		기본형이나 String같은 경우에는 모델에 저장할 필요가 x, 뷰에서 바로 쓸수 있기 때문에! (ex: ${param.parameter~})
		
	3.WebDataBinder
		컨트롤러의 메서드가 선언되어있고 메서드(url 등으로)호출을 했을때 쿼리스트링 데이터가 map형식으로 저장이 되는데, 매개변수로 받은 String을 int로 변환해주는것! 
		★1.타입변환 : 쿼리스트링으로 받은값과 매개변수에 입력되어야 하는 값의 데이터가 일치해? 안하면 바꿔준다.
		★2.데이터 검증 : 타입변환이 이루어진다해도 월의 요소에는 1~12만 들어와야 하니까 유효한지 확인!
		타입 변환결과를 BindingResult에 저장한다.(에러도 저장) 
		검증은 Validation 내가 정해놓은 틀에 맞게 들어갔는지 확인한다고 보면된다 예를들어 월은 1~12 일은 1~31일 처럼
		이 검증한 결과 또한 BindigResult에 저장 이 결과를 컨트롤러에 보내주고 컨트롤러는 이 결과값을 가지고 처리한다.(BindingResult result)
		바인딩데이터의 매개변수 위치는 처리할 데이터 바로 뒤에 위치해야한다.
		
		변환과 검증에서 더 자세히 나올것.
		
		여기서 알아가야할것은 : ★★브라우저를 통해서 요청받은 값이 실제 객체의 바인딩 될때 중간역할을 해주는것이 WebDataBinder이다.
		WebDataBinder는 타입변환, 데이터 검증하고 그 결과를 BindingResult에다 저장을하고 이 값을 컨트롤러에 넘겨주고 컨트롤러가 그 결과를 볼수 있다.
		